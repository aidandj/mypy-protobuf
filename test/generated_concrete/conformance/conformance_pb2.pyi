"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Protocol Buffers - Google's data interchange format
Copyright 2008 Google Inc.  All rights reserved.

Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file or at
https://developers.google.com/open-source/licenses/bsd
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _WireFormat:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _WireFormatEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_WireFormat.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    UNSPECIFIED: _WireFormat.ValueType  # 0
    PROTOBUF: _WireFormat.ValueType  # 1
    JSON: _WireFormat.ValueType  # 2
    JSPB: _WireFormat.ValueType  # 3
    """Only used inside Google. Opensource testees just skip it."""
    TEXT_FORMAT: _WireFormat.ValueType  # 4

class WireFormat(_WireFormat, metaclass=_WireFormatEnumTypeWrapper):
    """This defines the conformance testing protocol.  This protocol exists between
    the conformance test suite itself and the code being tested.  For each test,
    the suite will send a ConformanceRequest message and expect a
    ConformanceResponse message.

    You can either run the tests in two different ways:

      1. in-process (using the interface in conformance_test.h).

      2. as a sub-process communicating over a pipe.  Information about how to
         do this is in conformance_test_runner.cc.

    Pros/cons of the two approaches:

      - running as a sub-process is much simpler for languages other than C/C++.

      - running as a sub-process may be more tricky in unusual environments like
        iOS apps, where fork/stdin/stdout are not available.
    """

UNSPECIFIED: WireFormat.ValueType  # 0
PROTOBUF: WireFormat.ValueType  # 1
JSON: WireFormat.ValueType  # 2
JSPB: WireFormat.ValueType  # 3
"""Only used inside Google. Opensource testees just skip it."""
TEXT_FORMAT: WireFormat.ValueType  # 4
Global___WireFormat: typing_extensions.TypeAlias = WireFormat

class _TestCategory:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _TestCategoryEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_TestCategory.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    UNSPECIFIED_TEST: _TestCategory.ValueType  # 0
    BINARY_TEST: _TestCategory.ValueType  # 1
    """Test binary wire format."""
    JSON_TEST: _TestCategory.ValueType  # 2
    """Test json wire format."""
    JSON_IGNORE_UNKNOWN_PARSING_TEST: _TestCategory.ValueType  # 3
    """Similar to JSON_TEST. However, during parsing json, testee should ignore
    unknown fields. This feature is optional. Each implementation can decide
    whether to support it.  See
    https://developers.google.com/protocol-buffers/docs/proto3#json_options
    for more detail.
    """
    JSPB_TEST: _TestCategory.ValueType  # 4
    """Test jspb wire format. Only used inside Google. Opensource testees just
    skip it.
    """
    TEXT_FORMAT_TEST: _TestCategory.ValueType  # 5
    """Test text format. For cpp, java and python, testees can already deal with
    this type. Testees of other languages can simply skip it.
    """

class TestCategory(_TestCategory, metaclass=_TestCategoryEnumTypeWrapper): ...

UNSPECIFIED_TEST: TestCategory.ValueType  # 0
BINARY_TEST: TestCategory.ValueType  # 1
"""Test binary wire format."""
JSON_TEST: TestCategory.ValueType  # 2
"""Test json wire format."""
JSON_IGNORE_UNKNOWN_PARSING_TEST: TestCategory.ValueType  # 3
"""Similar to JSON_TEST. However, during parsing json, testee should ignore
unknown fields. This feature is optional. Each implementation can decide
whether to support it.  See
https://developers.google.com/protocol-buffers/docs/proto3#json_options
for more detail.
"""
JSPB_TEST: TestCategory.ValueType  # 4
"""Test jspb wire format. Only used inside Google. Opensource testees just
skip it.
"""
TEXT_FORMAT_TEST: TestCategory.ValueType  # 5
"""Test text format. For cpp, java and python, testees can already deal with
this type. Testees of other languages can simply skip it.
"""
Global___TestCategory: typing_extensions.TypeAlias = TestCategory

@typing.final
class TestStatus(google.protobuf.message.Message):
    """Meant to encapsulate all types of tests: successes, skips, failures, etc.
    Therefore, this may or may not have a failure message. Failure messages
    may be truncated for our failure lists.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    FAILURE_MESSAGE_FIELD_NUMBER: builtins.int
    MATCHED_NAME_FIELD_NUMBER: builtins.int
    name: builtins.str
    failure_message: builtins.str
    matched_name: builtins.str
    """What an actual test name matched to in a failure list. Can be wildcarded or
    an exact match without wildcards.
    """
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        failure_message: builtins.str = ...,
        matched_name: builtins.str = ...,
    ) -> None: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["failure_message", b"failure_message", "matched_name", b"matched_name", "name", b"name"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___TestStatus: typing_extensions.TypeAlias = TestStatus

@typing.final
class FailureSet(google.protobuf.message.Message):
    """The conformance runner will request a list of failures as the first request.
    This will be known by message_type == "conformance.FailureSet", a conformance
    test should return a serialized FailureSet in protobuf_payload.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TEST_FIELD_NUMBER: builtins.int
    @property
    def test(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___TestStatus]: ...
    def __init__(
        self,
        *,
        test: collections.abc.Iterable[Global___TestStatus] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["test", b"test"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___FailureSet: typing_extensions.TypeAlias = FailureSet

@typing.final
class ConformanceRequest(google.protobuf.message.Message):
    """Represents a single test case's input.  The testee should:

      1. parse this proto (which should always succeed)
      2. parse the protobuf or JSON payload in "payload" (which may fail)
      3. if the parse succeeded, serialize the message in the requested format.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PROTOBUF_PAYLOAD_FIELD_NUMBER: builtins.int
    JSON_PAYLOAD_FIELD_NUMBER: builtins.int
    JSPB_PAYLOAD_FIELD_NUMBER: builtins.int
    TEXT_PAYLOAD_FIELD_NUMBER: builtins.int
    REQUESTED_OUTPUT_FORMAT_FIELD_NUMBER: builtins.int
    MESSAGE_TYPE_FIELD_NUMBER: builtins.int
    TEST_CATEGORY_FIELD_NUMBER: builtins.int
    JSPB_ENCODING_OPTIONS_FIELD_NUMBER: builtins.int
    PRINT_UNKNOWN_FIELDS_FIELD_NUMBER: builtins.int
    protobuf_payload: builtins.bytes
    json_payload: builtins.str
    jspb_payload: builtins.str
    """Only used inside Google.  Opensource testees just skip it."""
    text_payload: builtins.str
    requested_output_format: Global___WireFormat.ValueType
    """Which format should the testee serialize its message to?"""
    message_type: builtins.str
    """The full name for the test message to use; for the moment, either:
    protobuf_test_messages.proto3.TestAllTypesProto3 or
    protobuf_test_messages.proto2.TestAllTypesProto2 or
    protobuf_test_messages.editions.proto2.TestAllTypesProto2 or
    protobuf_test_messages.editions.proto3.TestAllTypesProto3 or
    protobuf_test_messages.editions.TestAllTypesEdition2023.
    """
    test_category: Global___TestCategory.ValueType
    """Each test is given a specific test category. Some category may need
    specific support in testee programs. Refer to the definition of
    TestCategory for more information.
    """
    print_unknown_fields: builtins.bool
    """This can be used in json and text format. If true, testee should print
    unknown fields instead of ignore. This feature is optional.
    """
    @property
    def jspb_encoding_options(self) -> Global___JspbEncodingConfig:
        """Specify details for how to encode jspb."""

    def __init__(
        self,
        *,
        protobuf_payload: builtins.bytes = ...,
        json_payload: builtins.str = ...,
        jspb_payload: builtins.str = ...,
        text_payload: builtins.str = ...,
        requested_output_format: Global___WireFormat.ValueType = ...,
        message_type: builtins.str = ...,
        test_category: Global___TestCategory.ValueType = ...,
        jspb_encoding_options: Global___JspbEncodingConfig | None = ...,
        print_unknown_fields: builtins.bool = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["json_payload", b"json_payload", "jspb_encoding_options", b"jspb_encoding_options", "jspb_payload", b"jspb_payload", "payload", b"payload", "protobuf_payload", b"protobuf_payload", "text_payload", b"text_payload"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["json_payload", b"json_payload", "jspb_encoding_options", b"jspb_encoding_options", "jspb_payload", b"jspb_payload", "message_type", b"message_type", "payload", b"payload", "print_unknown_fields", b"print_unknown_fields", "protobuf_payload", b"protobuf_payload", "requested_output_format", b"requested_output_format", "test_category", b"test_category", "text_payload", b"text_payload"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_payload: typing_extensions.TypeAlias = typing.Literal["protobuf_payload", "json_payload", "jspb_payload", "text_payload"]
    _WhichOneofArgType_payload: typing_extensions.TypeAlias = typing.Literal["payload", b"payload"]
    def WhichOneof(self, oneof_group: _WhichOneofArgType_payload) -> _WhichOneofReturnType_payload | None: ...

Global___ConformanceRequest: typing_extensions.TypeAlias = ConformanceRequest

@typing.final
class ConformanceResponse(google.protobuf.message.Message):
    """Represents a single test case's output."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARSE_ERROR_FIELD_NUMBER: builtins.int
    SERIALIZE_ERROR_FIELD_NUMBER: builtins.int
    TIMEOUT_ERROR_FIELD_NUMBER: builtins.int
    RUNTIME_ERROR_FIELD_NUMBER: builtins.int
    PROTOBUF_PAYLOAD_FIELD_NUMBER: builtins.int
    JSON_PAYLOAD_FIELD_NUMBER: builtins.int
    SKIPPED_FIELD_NUMBER: builtins.int
    JSPB_PAYLOAD_FIELD_NUMBER: builtins.int
    TEXT_PAYLOAD_FIELD_NUMBER: builtins.int
    parse_error: builtins.str
    """This string should be set to indicate parsing failed.  The string can
    provide more information about the parse error if it is available.

    Setting this string does not necessarily mean the testee failed the
    test.  Some of the test cases are intentionally invalid input.
    """
    serialize_error: builtins.str
    """If the input was successfully parsed but errors occurred when
    serializing it to the requested output format, set the error message in
    this field.
    """
    timeout_error: builtins.str
    """This should be set if the test program timed out.  The string should
    provide more information about what the child process was doing when it
    was killed.
    """
    runtime_error: builtins.str
    """This should be set if some other error occurred.  This will always
    indicate that the test failed.  The string can provide more information
    about the failure.
    """
    protobuf_payload: builtins.bytes
    """If the input was successfully parsed and the requested output was
    protobuf, serialize it to protobuf and set it in this field.
    """
    json_payload: builtins.str
    """If the input was successfully parsed and the requested output was JSON,
    serialize to JSON and set it in this field.
    """
    skipped: builtins.str
    """For when the testee skipped the test, likely because a certain feature
    wasn't supported, like JSON input/output.
    """
    jspb_payload: builtins.str
    """If the input was successfully parsed and the requested output was JSPB,
    serialize to JSPB and set it in this field. JSPB is only used inside
    Google. Opensource testees can just skip it.
    """
    text_payload: builtins.str
    """If the input was successfully parsed and the requested output was
    TEXT_FORMAT, serialize to TEXT_FORMAT and set it in this field.
    """
    def __init__(
        self,
        *,
        parse_error: builtins.str = ...,
        serialize_error: builtins.str = ...,
        timeout_error: builtins.str = ...,
        runtime_error: builtins.str = ...,
        protobuf_payload: builtins.bytes = ...,
        json_payload: builtins.str = ...,
        skipped: builtins.str = ...,
        jspb_payload: builtins.str = ...,
        text_payload: builtins.str = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["json_payload", b"json_payload", "jspb_payload", b"jspb_payload", "parse_error", b"parse_error", "protobuf_payload", b"protobuf_payload", "result", b"result", "runtime_error", b"runtime_error", "serialize_error", b"serialize_error", "skipped", b"skipped", "text_payload", b"text_payload", "timeout_error", b"timeout_error"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["json_payload", b"json_payload", "jspb_payload", b"jspb_payload", "parse_error", b"parse_error", "protobuf_payload", b"protobuf_payload", "result", b"result", "runtime_error", b"runtime_error", "serialize_error", b"serialize_error", "skipped", b"skipped", "text_payload", b"text_payload", "timeout_error", b"timeout_error"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_result: typing_extensions.TypeAlias = typing.Literal["parse_error", "serialize_error", "timeout_error", "runtime_error", "protobuf_payload", "json_payload", "skipped", "jspb_payload", "text_payload"]
    _WhichOneofArgType_result: typing_extensions.TypeAlias = typing.Literal["result", b"result"]
    def WhichOneof(self, oneof_group: _WhichOneofArgType_result) -> _WhichOneofReturnType_result | None: ...

Global___ConformanceResponse: typing_extensions.TypeAlias = ConformanceResponse

@typing.final
class JspbEncodingConfig(google.protobuf.message.Message):
    """Encoding options for jspb format."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    USE_JSPB_ARRAY_ANY_FORMAT_FIELD_NUMBER: builtins.int
    use_jspb_array_any_format: builtins.bool
    """Encode the value field of Any as jspb array if true, otherwise binary."""
    def __init__(
        self,
        *,
        use_jspb_array_any_format: builtins.bool = ...,
    ) -> None: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["use_jspb_array_any_format", b"use_jspb_array_any_format"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___JspbEncodingConfig: typing_extensions.TypeAlias = JspbEncodingConfig
